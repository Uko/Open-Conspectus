% These lines tell TeXShop to typeset with xelatex, and to open and 
% save the source with Unicode encoding.

%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\documentclass[12pt,a4paper]{book}
\usepackage{xltxtra}
\usepackage{makecell}
\usepackage[left=2cm,top=2cm,right=2cm,bottom=2cm]{geometry}
\usepackage{amsmath}
\usepackage{colortbl}
\usepackage[table]{xcolor}
\renewcommand{\chaptername}{Тема}
\setmainfont[Mapping=tex-text]{Times New Roman}

\newcommand{\diagcell}[4]{\diaghead({#1},{#2}){easterr}{#4}{#3}}

\newenvironment{slim_enumerate}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}}
{\end{enumerate}}

\newenvironment{slim_itemize}{
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}}
{\end{itemize}}

\begin{document}

\tableofcontents

\chapter{Вступ}

\emph{Операція} - сукупність дій, спрямованих на досягнення визначеної мети.

\emph{Дослідження операцій} - наука, що займається дослідженням реальних процесів-операцій, виробленням рекомендацій про прийняття рішень.

Кроки при розв'язуванні задач:
\begin{slim_enumerate}
  \item Постановка задачі.
  \item Побудова моделі.
  \item Відшукання розв'язку.
  \item Перевірка моделі та оцінка результату.
  \item Впровадження розв'язку та контроль його достовірності.
\end{slim_enumerate}

В залежності від задачі і побудованої моделі використовують різні методи, в той час, як один метод можна застосувати до різних задач. Зараз багато методів займаються лінійним програмуванням, теорією ігор і тд.

\section{Алгоритм Пріма}

Нехай дано простий зв’язний зважений граф $G=(V,E)$ і вагова функція $d:E\rightarrow R$.

Потрібно знайти мінімальний каркас $A_s$ в заданому графі, починаючи з вершини $x_s$.

Алгоритм Пріма:
\begin{slim_enumerate}
  \item Нехай $T_s = \{x_s\}$ - множина вершин, з’єднаних ребрами, що входять в мінімальний каркас,\\
$A_s = \{\emptyset\}$ - множина ребер, що входять в каркас мінімальної довжини.
  \item Записати:\\
$\forall x_j\in$ Г$(x_s)$ $[\alpha_j=x_s, \beta_j=d(x_s,x_j)]$ (Г$(x_s)$ - суміжні до $x_s$ вершини)\\
$\forall x_j\notin$ Г$(x_s)$ $[0,\infty]$
  \item Вибрати $x_j^*$, де $\beta_j^*=\displaystyle\min_{x_j\notin T_s}\{\beta_j\}$,\\
$T_s=T_s\cup\{x_j^*\}$,\\
$A_s=A_s\cup\{(\alpha_j^*,x_j^*)\}$.\\
Якщо $|T_s|=n\Rightarrow$ кінець,\\
інакше ${\Rightarrow}$ Крок 4.
  \item $\forall x_j\notin T_s, x_j\in$ Г$(x_j^*), \beta_j>d(x_j^*,x_j)$ оновити мітки:\\
$\beta_j=d(x_j^*,x_j), \alpha_j=x_j^*$.\\
Перейти на Крок 3.
\end{slim_enumerate}

*місце на граф (малюнок-приклад)*

\chapter{Алгоритми пошуку шляхів}

Нехай маємо орієнтований граф $G=(V,E)$, дугам якого ставляться у відповідність ваги, що задаються матрицею $A=A_{ij}$. Ставляться такі задачі знаходження найкоротшого(х) шляху(ів):
\begin{slim_enumerate}
  \item від заданої початкової - до заданої кінцевої вершини графа;
  \item між заданою початковою вершиною графа та всіма іншими вершинами графа;
  \item між усіма парами вершин графа.
\end{slim_enumerate}
Задачі 1) і 2) розв’язують алгоритми Дейкстри (ваги $\geq 0$) і Форда (ваги довільні).

Алгоритм Дейкстри чи Форда дозволяє знайти найкоротший шлях від деякої виділеної вершини графа до будь-якої іншої. Можна було б методом багаторазового використання одного з цих алгоритмів з послідовним перебором кожної вершини графа в ролі початкової розв’язати задачу 3), але це вимагало б великої обчислюваної роботи.

Більш ефективним методом розв’язування задачі 3) є алгоритм Флойда. Для дуг допускаються від’ємні ваги, але не допускається наявність від’ємного циклу.

\section{Алгоритм Форда}

\emph{Нагадування:} ваги довільні.

Припустимо, що немає циклів з від’ємною довжиною. Навідміну від алгоритму Дейкстри, ніяка із міток під час процесу не розглядаєтсья як остаточна.

Позначимо $l^k(x_i)$ - мітка вершини $x_i$ в кінці $k-1$ операції.
\begin{slim_enumerate}
  \item \emph{Присвоєння початкових значень}\\
Нехай $x_s$ - довільна початкова вершина,\\
покласти $S=$ Г$(x_s)$,\\
$k=1, l^1(x_s)=0;$\\
$\forall x_i \in$ Г$(x_s), l^1(x_i)=d(x_s,x_i)$\\
$\forall x_i \notin$ Г$(x_s), l^1(x_i)=\infty$
  \item \emph{Оновлення міток}\\
$\forall x_i \in$ Г$(S), (x_i \neq x_s)$ знайти її мітку наступним чином:\\
$T_i=$ Г$^{-1}(x_i) \cap S$,\\
$l^{k+1}(x_i)=\min\{l^k(x_i),\displaystyle\min_{x_j \in T_i}[l^k(x_j)+d(x_j,x_i)]\}$ (тут важливий порядок - дуги),\\
$\forall x_i \notin$ Г$(S): l^{k+1}(x_i)=l^k(x_i)$
  \item \emph{Перевірка на закінчення}
    \begin{slim_enumerate}
      \item $k \leq n-1$, якщо $\forall i$ $l^{k+1}(x_i)=l^k(x_i)$, то мітки рівні довжинам найкоротших шляхів. Кінець.
      \item $k<n-1$, якщо $\exists i$ $l^{k+1}(x_i) \neq l^k(x_i)$, то перейти до Кроку 4.
      \item $k=n-1$, якщо $\exists i$ $l^{k+1}(x_i) \neq l^k(x_i)$, то в графі присутній цикл від’ємної довжини і \emph{задача не має розв’язку}. Кінець.
    \end{slim_enumerate}
  \item \emph{Підготовка до наступної ітерації}\\
Оновити мітку наступним чином:
$$S=\{x_i:l^{k+1}(x_i) \neq l^k(x_i)\}$$
  \item Покласти $k=k+1$ і перейти до Кроку 2.
\end{slim_enumerate}

Коли довжини найкоротших шляхів будуть знайдені то самі шляхи отримаємо рекурсивно:
$$l(x_i')+d(x_i',x_i)=l(x_i),$$
$x_i'$ - вершина, що безпосередньо передує $x_i$ на шляху від $x_s$.

\section{Алгоритм Флойда}

Застосовується до графів з довільними дугами, але не допускається наявність циклу від’ємної довжини.

В алгоритмі використовуються дві, оновлювані в його процесі, матриці: матриця ваг - $D$ і матриця попередніх вершин - $\Theta$. Прицьому, на $k$-й ітерації елементи матриці ваг $D_{(k)}=\{d_{ij}^{(k)}\}$ позначають найкоротший шлях між вершинами $x_i$ та $x_j$, який може складатись із внутрішніх (проміжних) вершин з множини перших $k$ вершин графу - $\{x_1, ..., x_k\}$ а елементи матриці $\Theta=\{\theta_{ij}^{(k)}\}$ позначають вершини, що безпосереньо передують вершинам $x_j$ у біжучому найкоротшому шляху від $x_i$ до $x_j$.

\emph{Внутрішня (проміжна) вершина - вершина графу, що не збігається з його початковою або кінцевою вершиною.}

\begin{slim_enumerate}
  \item \emph{Присвоєння початкових значень}\\
Нехай задано зважений граф $G=(V,E)$ i вагова функція $d:E \rightarrow R$.
$k=0$\\
$\forall (i,j) \in E d_{ij}^{(k)}=d(x_i,x_j)$ (є дуги)\\
$\forall (i,j) \notin E d_{ij}^{(k)}=\infty$ (дуги відсутні)\\
$d_{ii}^{(k)}=0$ (діагональні)\\
$\theta_{ij}^{(k)}=x_i$
  \item $k=k+1$
  \item $\forall i: i \neq k, d_{ik}^{(k-1)} \neq \infty, \forall j: j \neq k, d_{kj}^{(k-1)} \neq \infty, d_{ij}^{(k-1)}>d_{ik}^{(k-1)}+d_{kj}^{(k-1)}$ оновити матриці:\\
$d_{ij}^{(k)}=d_{ik}^{(k-1)}+d_{kj}^{(k-1)}$\\
$\theta_{ij}^{(k)}=\theta_{kj}^{(k-1)}$\\
Для всіх інших $i$ та $j$ переписати попередні елементи:\\
$d_{ij}^{(k)}=d_{ij}^{(k-1)}$,\\
$\theta_{ij}^{(k)}=\theta_{ij}^{(k-1)}$.
  \item 
    \begin{slim_enumerate}
      \item $d_{ii}^{(k)} < 0$ - в графі пристуній цикл від’ємної довжини, що містить вершину $x_i$ - розв’язку не існує. Кінець.
      \item $d_{ii}^{(k)} \geq 0, k=n$ - маємо розв’язок - матриця $D^{(n)}$ містить найкоротші шляхи між вершинами графу. Кінець.
      \item $d_{ii}^{(k)} \geq 0, k<n$ - перейти на Крок 2.
    \end{slim_enumerate}
\end{slim_enumerate}

\emph{Зауваження.} Якщо в початковій матриці $D^{(0)}$ усі діагональні елементи покласти рівними $\infty$ то $d_{ii}^{(n)}$ буде рівним вазі ланцюга що проходить через $x_i$.

\chapter{Лінійні моделі дослідження операцій}

У випадку, якщо вихідна задача не є лінійною, то на першому етапі дослідження її або вважають лінійною, або всі залежності замінюються лінійними. Для побудови методу використовується апарат лінійного програмування.

\section{Транспортна задача}

Нехай маємо $m$ пунктів виробництва однорідного продукту (бази, склади, ...) з потужностями, відповідно, $a_i, i = \overline{1, m}$. Маємо $n$ пунктів споживання, відповідно, з потребами $b_j, j =\overline{1, n}$.

Задається матриця перевезень $С = \{c_{ij}\}$, де $c_{ij}$ - вартість перевезення одиниці продукту з $i$-того пункту виробництва в $j$-й пункт споживання.

Потрібно знайти такий набір $x_{ij} \geq 0, i = \overline{1, m}, j = \overline{1, n}$, де  $x_{ij}$ - кількість одиниць продукту, яка перевозиться з $і$-го пункту виробництва в $j$-й пункт споживання, щоб виконувались наступні умови: 
\begin{equation}  \sum_{j=1}^n x_{ij} = a_i, i = \overline{1, m}. \end{equation}
\begin{equation} \sum_{i=1}^m x_{ij} = b_j, j = \overline{1, n}.   \end{equation}
\begin{equation} \sum_{i=1}^m \sum_{j=1}^n c_{ij} x_{ij} \to \min  \end{equation}

Невідємний набір $x_{ij}$, який задовольняє (3.1), (3.2), називається \emph{планом задачі} або \emph{допустимим розвязком}. Той із планів, який надає мінімум в (3.3), називається \emph{оптимальним планом} або розвязком транспортної задачі.

\emph{Зауважимо}, що транспортна задача, поставлена в такій формі, називається "транспортною задачею за критерієм вартості".

Умова \begin{equation}  \sum_{i=1}^n a_i = \sum_{j=1}^m b_j  \end{equation} називається умовою \emph{балансу мас}.

Транспортну задачу зручно зображати таблицею:\\
\begin{tabular}{ | c | c | c | c | c | }
\hline
\diaghead(4,3){easterr}{$c_{1 2}$}{$x_{1 2}$} & \diaghead(4,3){easterr}{$c_{1 2}$}{$x_{1 2}$} & \thead{\vdots} & \diaghead(4,3){easterr}{$c_{1 n}$}{$x_{1 n}$} & \thead{$a_1$} \\
\hline
\diaghead(4,3){easterr}{$c_{2 1}$}{$x_{2 1}$} & \diaghead(4,3){easterr}{$c_{2 2}$}{$x_{2 2}$} & \thead{\vdots} & \diaghead(4,3){easterr}{$c_{2 n}$}{$x_{2 n}$} & \thead{$a_2$} \\
\hline
 \thead{$\cdots$} & \thead{$\cdots$} & \thead{$\ddots$} & \thead{$\cdots$} & \thead{$\cdots$} \\
\hline
\diaghead(4,3){easterr}{$c_{m 1}$}{$x_{m 1}$} & \diaghead(4,3){easterr}{$c_{m 2}$}{$x_{m 2}$} & \thead{\vdots} & \diaghead(4,3){easterr}{$c_{m n}$}{$x_{m n}$} & \thead{$a_m$} \\
\hline
\thead{$b_1$} & \thead{$b_2$} & \thead{\vdots} & \thead{$b_n$} & \thead{} \\
\hline
\end{tabular}

Матричний вигляд умов (3.1), (3.2) - матриця обмежень:\\
\begin{tabular}{ @{\hspace{1.4em}}l l }
$
\setlength{\arraycolsep}{0.27em}
\begin{array}{ccccccccccccc}
A_{1 1} & A_{1 2} & \dots & A_{1 n} & A_{2 1} & A_{2 2} & \dots & A_{2 n} & \dots & A_{m 1} & A_{m 2} & \dots & A_{m n} 
\end{array}$ &  \\
\multicolumn{2}{l}{
$\left(
 \begin{array}{ccccccccccccc}
1 & 1 & \dots & 1 & 0 & 0 & \dots & 0 & \dots & 0 & 0 & \dots & 0 \\
0 & 0 & \dots & 0 & 1 & 1 & \dots & 1 & \dots & 0 & 0 & \dots & 0 \\
\dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots \\
0 & 0 & \dots & 0 & 0 & 0 & \dots & 0 & \dots & 1 & 1 & \dots & 1 \\
1 & 0 & \dots & 0 & 1 & 0 & \dots & 0 & \dots & 1 & 0 & \dots & 0 \\
\dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots \\
0 & 0 & \dots & 1 & 0 & 0 & \dots & 1 & \dots & 0 & 0 & \dots & 1
\end{array}\right)
\left(\begin{array}{c}
x_{1 1} \\
x_{1 2} \\
\dots \\
x_{1 n} \\
x_{m 1} \\
\dots \\
x_{m n}
\end{array}
\right)
=
\left(\begin{array}{c}
a_1 \\
a_2 \\
\dots \\
a_m \\
b_1 \\
\dots \\
b_n
\end{array}
\right)$}
\end{tabular}

\subsection{Теорема 1}

Ранг матриці обмежень транспортної задачі рівний $r=m+n-1$.

{\bf Доведення:}

Оскільки сума перших рівнянь (3.1) рівна сумі наступних $n$ рівнянь (3.2), тобто виконується умова (3.4), то звідси випливає, що $r \leq m+n-1$.

Для того, щоб показати, що $r=m+n-1$ виділимо в матриці обмежень квадратну матрицю розмірності $m+n-1$ визначник якої нерівний нулю. Для цього можна взяти вектори:\\
\begin{tabular}{ @{\hspace{1em}}l l }
$
\setlength{\arraycolsep}{0.23em}
\begin{array}{cccccccc}
A_{1 n} & A_{2 n} & \dots & A_{m n} &  A_{1 1} & A_{1 2} & \dots & A_{1 n-1} 
\end{array}$ &  \\
\multicolumn{2}{l}{
$\left|
 \begin{array}{cccccccc}
1 & 0 & \dots & 0 & 1 & 1 & \dots & 1 \\
0 & 1 & \dots & 0 & 0 & 0 & \dots & 0 \\
\dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots \\
0 & 0 & \dots & 1 & 0 & 0 & \dots & 0 \\
0 & 0 & \dots & 0 & 1 & 0 & \dots & 0 \\
0 & 0 & \dots & 0 & 0 & 1 & \dots & 0 \\
\dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots \\
0 & 0 & \dots & 0 & 0 & 0 & \dots & 1 
\end{array}\right|$}
\end{tabular}
$\neq 0$

\subsection{Теорема  2}

Для розвязності транспортної задачі необхідно і достатньо, щоб виконувалась умова балансу мас $\sum_{i=1}^m a_i = \sum_{j=1}^n b_j$ .

{\bf Доведення:}

{\it Необхідність.} Нехай $ x_{ij}^*, i = \overline{1, m}, j = \overline{1, n}$ , - розвязок транспортної задачі.

Оскільки  $\sum_{j=1}^n x_{ij}^* = a_i,  i = \overline{1, m};  \sum_{i=1}^m  x_{ij}^* = b_j ,  j = \overline{1, n}$ , то отримаємо $\sum_{i=1}^n a_i = \sum_{j=1}^m b_j$.

{\it Достатність.} Нехай виконується умова балансу мас, покладемо  $x_{ij} = \frac{a_ib_j}{\sum_{i=1}^m a_i}$. Сумуючи це співвідношення по $j$, отримаємо:

$\sum_{j=1}^n x_{ij} = \sum_{j=1}^n \frac{a_ib_j}{\sum_{i=1}^m a_i} = a_i,  i = \overline{1, m}.$

$\sum_{i=1}^m x_{ij} = \sum_{i=1}^m \frac{a_ib_j}{\sum_{i=1}^m a_i} = b_j,  j = \overline{1, n}.$

\section{Властивості опорних планів транспортної задачі}

План $\{x_{ij}\}_{m,n}$ транспортної задачі називають \emph{опорним планом}, якщо вектори $A_{ij}$ (з матриці обмежень), що відповідають додатним компонентам плану лінійно незалежні.

Оскільки із Т1 $\Rightarrow$ ранг матриці обмедень транспортної задачі $r=m+n-1$, то додатних компонент опорний план може мати не більше ніж $m+n-1$.

\begin{itemize}
  \item Опорний план, який має рівно $m+n-1$ додатних компонент - невироджений.
  \item Опорний план, який має менше $m+n-1$ додатних компонент - вироджений.
\end{itemize}

\emph{Базисом ОП} називається довільна система із $m+n-1$ лінійно незалежних векторів $A_{ij}$, яка містить усі вектори $A_{ij}$, що відповідають додатним компонентам плану.

Поставимо взаємовідповідність між клітинами транспонованої таблиці і векторами $A_{ij}$. Кожній клітині $(i,j) \leftrightarrow A_{ij}$.

Набір клітин $$(i_1,j_1),(i_1,j_2),(i_2,j_2),\dots,(i_s,j_1)$$або$$(i_1,j_1),(i_2,j_1),(i_2,j_2),\dots,(i_1,j_s)$$
називають \emph{ланцюжком}. Звідси видно, що два сусідні елементи ланцюжка лежать або в одному рядку або в одному стовпчику.

\emph{Зауважимо}, що кількість елементів замкненого ланцюжка завжди парна.

\dots табличка з прикладом ланцюжка \dots

Нехай $P$ - довільна система векторів $A_{ij}$ умов транспортної задачі, $I$ - множина пар індексів $(i,j)$, які відповідають векторам $A_{ij} \in P$.

\subsection{Теорема 3}

Для того, щоб система векторів $P$ була лінійно незалежною необхідно і достатньо, щоб із елементів множини $I$ неможна було скласти замкнений ланцюжок.

{\bf Доведення:}

{\it Необхідність.} $P$ - лінійно незалежна система, покажем, що неможна замкнути ланцюжок. {\it Від супротивного.} Припустимо, що із елементів множини $I$ можна скласти замкнений ланцюжок: $$(i_1,j_1), (i_1,j_2), (i_2,j_2), \dots, (i_s,j_1).$$ Звідси випливає, враховуючи вигляд векторів $A_i$, $$A_{{i_1},{j_1}}-A_{{i_1},{j_2}}+A_{{i_2},{j_2}}-\dots-A_{{i_s},{j_1}}=0,$$ а тому система векторів лінійно залежна, що суперечить вхідній умові.

{\it Достатність.} Припустимо, що замкнений ланцюжок не скласти. Покажемо, що система векторів лінійно незалежна. {\it Від супротивного.} Нехай вектори лінійно залежні. Звідси випливає, що $\exists \alpha_{ij} \neq 0, (i,j) \in I:$ $$\sum_{(i,j) \in I}\alpha_{ij}A_{ij} = 0.$$

Нехай $\alpha_{{i_1}{j_1}} \neq 0$, тоді: 
$$\sum_{(i,j) \in I}\alpha_{ij}A_{ij} = -\alpha_{{i_1}{j_1}}A_{{i_1}{j_1}};$$
$$I_1 = I\setminus\{(i_1,j_1)\}.$$

Компонента $i_1$ вектора в правій частині не рівна нулю, тому в лівій частині існує принаймі один вектор $A_{{i_1}{j_2}}: \alpha_{{i_1}{j_2}}\neq0$, тоді 
$$\sum_{(i,j){\in}I}\alpha_{ij}A_{ij} = -\alpha_{{i_1}{j_1}}A_{{i_1}{j_1}}-\alpha_{{i_1}{j_2}}A_{{i_1}{j_2}}.$$

Оскільки $j_1 \neq j_2$ і $m + j_2$ компонента парвої частини не рівна нулю, то знайдеться принаймі один вектор $A_{{i_2}{j_2}}: \alpha_{{i_2}{j_2}} \neq 0$, тоді $$\sum_{(i,j) \in I}\alpha_{ij}A_{ij} = -\alpha_{{i_1}{j_1}}A_{{i_1}{j_1}}-\alpha_{{i_1}{j_2}}A_{{i_1}{j_2}}-\alpha_{{i_2}{j_2}}A_{{i_2}{j_2}}.$$
і т.д.

Цей процес скінченний, оскільки всі вектори в лівій частині різні, то врезультаті приходимо до:
$$0 = -\alpha_{{i_1}{j_1}}A_{{i_1}{j_1}}-\alpha_{{i_2}{j_1}}A_{{i_2}{j_1}}-\dots-\alpha_{{i_k}{j_k-1}}A_{{i_k}{j_k-1}}, i_k=i_s, 1 \leq s \leq k-2;$$
$$0 = -\alpha_{{i_1}{j_1}}A_{{i_1}{j_1}}-\alpha_{{i_1}{j_2}}A_{{i_1}{j_2}}-\dots-\alpha_{{i_k}{j_{k+1}}}A_{{i_k}{j_{k+1}}}, j_{k+1}=j_l, l \leq 1 \leq k-1.$$

Тоді із елементів $(i_1,j_1), (i_1,j_2), \dots, (i_k,j_k)$ можна скласти замкнений ланцюг:
$$(i_s,j_s), (i_{s+1},j_s), \dots, (i_k = i_s, j_{k-1})$$
$$(i_l,j_l), (i_l,j_{l+1}), \dots, (i_k, j_{k+1} = j_l),$$
що суперечить нашому припущенню.

\subsection{Теорема 4}

Нехай система векторів $P$ - лінійно-незалежна, $A_{kl} \notin P$. $I$ - множина пар індексів $(i,j)$, які відповідають векторам $A_{ij} \in P$.

Вектор $A_{kl}$ можна виразити через вектори системи $P$ тоді і тільки тоді, коли із пар індексів $(i,j)$ можна скласти ланцюг, що замикається на клітині $(k,l)$.

{\bf Доведення:}

{\it Необхідність.} Припустимо, що вектор $A_{kl}$ можна виразити через вектори системи $P$, покажемо, що можливо утворити ланцюг із елементів множини $I$, що замикається на клітині $(k,l)$. з припущення випливає, що система $P'=P \cup \{A_{kl}\}$ - лінійно залежна. Тоді з критерію лінійної незалежності системи векторів-умов ТЗ випливає, що із пар індексів множини $I'=I \cup \{(k,l)\}$ можна побудувати ланцюжок. Причому цей ланцюг проходить через клітину $(k,l)$, так як у протилежному випадку - система векторів $P$ була б лінійно залежною, що суперечить умові.

{\it Достатність.} Візьмемо ланцюг $I'$, що замикається на клітині $(k,l)$ і покажемо, що вектор $A_{kl}$ можна виразити через $P$:
$$(k,j_1),(i_1,j_1),\dots,(i_s,l),(k,l).$$
Враховуючи вигляд векторів $A_{ij}$ можна записати:
$$A_{kj_1} - A_{i_1j_1} + \dots + A_{i_sl} - A_{kl} = 0.$$
Звідси видно, що $A_{kl}$ - лінійна комбінація векторів $A_{ij} \in P$.


\section{Методи побудови початкових опорних планів транспортної задачі}

\subsection{Метод Північно-Західного кута}

Припустимо, що ТЗ задана таблично:\\
\begin{tabular}{ | c | c | c | c | c |}
\hline
$x_{11}$/$c_{11}$	&	/$c_{12}$	&	\dots	&	/$c_{1n}$	&	$a_1$\\
\hline
$x_{21}$/$c_{21}$	&	/$c_{22}$	&	\dots	&	/$c_{2n}$	&	$a_2$\\
\hline
\dots	&	\dots	&	\dots	&	\dots	&	\dots\\
\hline
$x_{m1}$/$c_{m1}$	&	/$c_{m2}$	&	\dots	&	/$c_{mn}$	&	$a_m$\\
\hline
$b_1$	&	$b_2$	&	\dots	&	$b_n$	&\\
\hline
\end{tabular}

Заповнюєм транспортну таблицю починаючи з крайнього верхнього і лівого кута.
$$x_{11} = \min\{a_1,b_1\}=a_1.$$
Це означає, що запас першого пункту вичерпаний із наступного розподілу цей пункт виключаємо, а потреби першого пункту споживання рівні $b'_1=b_1-a_1$.
$$x_{21} = \min\{a_2,b'_1\} = \min\{a_2,b_1-a_1\} = b'_1.$$
$$a'_2=a_2-b'_1=a_2-(b_1-a_1).$$

При заповненні останньої клітини, оскільки в нас виконується умова балансу мас, можливості і потреби повинні бути рівними.

Із попередньої теореми випливає, що план побудований таким методом є опорним.

\begin{tabular}{ | c | c | c | c | c |}
\hline
8/3	&	1/5	&	/4	&	/7		&	9\\
\hline
/7	&	9/8	&	6/9	&	/11		&	15\\
\hline
/4	&	/6	&	13/8	&	10/14	&	23\\
\hline
8	&	10	&	19	&	10		&\\
\hline
\end{tabular}
Отримали невироджений ОП, бо кількість заповнених клітин рівна $m+n-1 = 3+4-1 = 6$.

\subsection{Метод мінімального елементу}

При побудові початкового ОП методом Пн.-Зх. кута ми не враховували елементів матриці вартостей. Природно сподіватися, що коли враховувати елементи матриці вартостей, то отримаємо ОП кращий від попереднього, тобто затрати на перевезення будуть меншими. Таким методом є метод мінімального елементу.

Серед елементів матриці вартостей шукаємо мінімальний. Припустимо це елемент $c_{kl}$. Заповнення таблиці починаємо із клітини $(k,l)$, аналогічно як в попередньому методі.
$$x_{kl} = \min\{a_k,b_l\},$$
при цьому, або рядок, або стовпчик із наступного розгляду викреслюємо. Відповідно змінюємо або запас в $k-$му пункті постачання, або потреби $l-$го пункту споживання.

В матриці, що залишається знову шукаєм мінімальний елемент і т.д.

\begin{tabular}{ | c | c | c | c | c |}
\hline
\diagcell{4}{3}{8}{3}	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{1}{4}	&	\diagcell{4}{3}{}{7}		&	9\\
\hline
\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{8}	&	\diagcell{4}{3}{5}{9}	&	\diagcell{4}{3}{10}{11}	&	15\\
\hline
\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{10}{6}	&	\diagcell{4}{3}{13}{8}	&	\diagcell{4}{3}{}{14}		&	23\\
\hline
8	&	10	&	19	&	10		&\\
\hline
\end{tabular}

\subsection{Метод Фогеля}

В кожному рядку шукаємо мінімальний елемент і наступний за ним по величині. Різницю записуємо справа від рядка. Аналогічно поступаєво із стовпчиками, записуємо внизу кожного.

Серед отриманих різниць шукаємо максимальну і в стовпчику чи рядку, якому віповідає максимальна різниця шукаємо мінімальний елемент матриці вартостей.

Заповнення транспортної таблиці починаємо з отриманої клітини аналогічно як і в попередніх методах.

\begin{tabular}{ | c | c | c | c | c |}
\hline
\diagcell{4}{3}{}{3}	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{9}{4}	&	\diagcell{4}{3}{}{7}		&	9\\
\hline
\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{8}	&	\diagcell{4}{3}{5}{9}	&	\diagcell{4}{3}{10}{11}	&	15\\
\hline
\diagcell{4}{3}{8}{4}	&	\diagcell{4}{3}{10}{6}	&	\diagcell{4}{3}{5}{8}	&	\diagcell{4}{3}{}{14}		&	23\\
\hline
8	&	10	&	19	&	10		&\\
\hline
\end{tabular}

\section{Двоїста ТЗ}

ТЗ є задачею лінійного програмування, а тому можемо записати двоїсту до неї.

Запишемо вихідну ТЗ.

\begin{equation} \sum_{i=1}^m \sum_{j=1}^n c_{ij} x_{ij} \to \min \end{equation}
\begin{equation}  \sum_{j=1}^n x_{ij} = a_i, i = \overline{1, m}. \end{equation}
\begin{equation} \sum_{i=1}^m x_{ij} = b_j, j = \overline{1, n}. \end{equation}
\begin{equation} x_{ij} \geq 0, i = \overline{1, m}, j = \overline{1, n} \end{equation}

Кожному обмеженню (3.6) поставимо у відповідність змінну $u_i, i = \overline{1, m}$.

Кожному обмеженню (3.7) поставимо у відповідність змінну $v_j, j = \overline{1, n}$.

\begin{equation} L^* = \sum_{i=1}^m a_i u_i + \sum_{j=1}^n b_j v_j \to \max \end{equation}
\begin{equation} u_i+v_j \leq c_{ij}, i = \overline{1, m}, j = \overline{1, n} \end{equation}

Матриця обмежень:\\
\begin{tabular}{ @{\hspace{1.4em}}l l }
  \multicolumn{2}{l}{
    $\left(\begin{array}{c}
        $Транспонована матриця обмежень $[m*n \times m+n]\\
      \end{array}\right)
    \left(\begin{array}{c}
        u_1 \\
        \dots \\
        u_m \\
        v_1 \\
        \dots \\
        v_n
      \end{array}\right)
\leq
    \left(\begin{array}{c}
        c_{11} \\
        c_{12} \\
        \dots \\
        c_{mn}
      \end{array}\right)$}
\end{tabular}

\section{Умови оптимальності ТЗ}

Зауважимо, що змінні $u_i$ відповідають обмеженням (3.6), а обмеження (3.6) - відповідають рядкам таблиці ТЗ, тому змінні $u_i$ відповідають рядкам таблиці ТЗ. Аналогічно, змінні $v_j$ відповідають обмеженням (3.7), а (3.7) - відповідають стовпцям таблиці ТЗ, тому $v_j$ відповідають стовпцям таблиці ТЗ.

\subsection{Теорема}

План $x_{ij}$ ТЗ - оптимальний, тоді і тільки тоді, коли для будь-якого рядка $i$ та кожного стовпчика $j$ знайдуться такі числа-потенціали $u_1,\dots,u_m,v_1,\dots,v_n$, що задовільняють умови:
\begin{equation} u_i+v_j = c_{ij}, x_{ij}>0 \end{equation}
\begin{equation} u_i+v_j \leq c_{ij}, x_{ij}=0 \end{equation}

{\bf Доведення:}

{\it Достатність.} Умови (3.11) і (3.12) виконуються. Візьмемо довільний план $\tilde{x_{ij}}$, тоді:\\
$$ L(\tilde{x}_{ij}) = \sum_{i=1}^m \sum_{j=1}^n c_{ij} \tilde{x}_{ij} \geq
 \sum_{i=1}^m \sum_{j=1}^n (u_i+v_j) \tilde{x}_{ij} = 
 \sum_{i=1}^m \sum_{j=1}^n \tilde{x}_{ij} u_i + \sum_{i=1}^m \sum_{j=1}^n  \tilde{x}_{ij} v_j = $$
$$ = \sum_{i=1}^m a_i u_i + \sum_{j=1}^n b_j v_j =
 \sum_{i=1}^m \sum_{j=1}^n x_{ij} u_i + \sum_{i=1}^m \sum_{j=1}^n  x_{ij} v_j =
 \sum_{i=1}^m \sum_{j=1}^n (u_i+v_j) x_{ij} = $$
$$ = \sum_{i=1}^m \sum_{j=1}^n c_{ij} x_{ij} = L(x_{ij}). $$

Отже $x_{ij}$ - оптимальний план.

{\it Необхідність.} $x_{ij}$ - оптимальний план. Оскільки задача (3.5) - (3.8) (ТЗ) має розв’язок, то в силу 1 теореми двоїстості - двоїста задача також має розв’язок: $u^*_i, i = \overline{1,m}, v^*_j, j= \overline{1,n}$. Звідси випливає, що: $u^*_i+v^*_j \leq c_{ij}, i = \overline{1,m}, v^*_j, j= \overline{1,n}$ - виконується умова (3.12).

З 2 теоремою двоїстості $\Rightarrow (u^*_i + v^*_j - c_{ij})x_{ij}=0$. Звідси, якщо $x_{ij}>0$, то $u^*_i + v^*_j = c_{ij}$ - виконується умова (3.11).

\subsection{Метод потенціалів (розв’язування ТЗ)}

\emph{(Базується на умові оптимальності плану ТЗ).}

\begin{slim_enumerate}
  \item \emph{Попередній крок.} Знайти початковий опороний план будь-яким із методів, наприклад методом „Пн-Зх кута“. Припустимо, що план - невироджений.

  \item \emph{Перевірка оптимальності.} Для клітин, які ввійшли в початковий опорний план і які будем називати „заповненими“, використовуючи умову $u_i + v_j = c_{ij}, x_{ij} > 0$, шукаємо числа потенціали $u_i, v_j$. Так як всього невідомих є $n+m$, а заповнених клітин - $m+n-1$, то довільній із змінних, наприклад $u_1$, присвоюємо $0$ і знаходимо всі решту.

Всі інші клітини, які називатимемо "вільними" перевіряєм на умову оптимальності - $u_i + v_j \leq c_{ij}, x_{ij} = 0$:
\begin{equation} \sigma_{ij} = c_{ij} - u_i - v_j \geq 0\end{equation}
Якщо всі вільні клітини задовільняють цю умову - то маємо оптимальний план, в іншому випадку - будемо його покращувати.

  \item \emph{Покращення плану.} Вибрати клітину з найбільшим порушенням умови, нехай це клітина $(k,l)$ - $\sigma_{kl} = \min \sigma_{ij}$.

\emph{Зауваження.} Можна вибирати будь-яку іншу, або першу, клітину з порушенням умови потимальності, але вибір клітини з найбільшим порушенням приводить до оптимального плану швидше.

Із заповнених клітин, будуємо ланцюжок, який замикається на клітині $(k,l)$. Позначаємо клітини почерзі знаками "$+$","$-$", причому клітину $(k,l)$ позначаємо знаком "+". Серед клітин із знаком "$-$" вибираєм клітину із найменшим значенням $x_{ij}$ (перевезенням). Віднімаємо це значення від значень в усіх клітинах із знаком "$-$" та додаємо до значень в клітинах із знаком "$+$". Отримали новий опорний план - повертаємся до перевірки його оптимальності.
\end{slim_enumerate}

\subsection{Метод потенціалів. Обґрунтування зменшення знаку лінійної форми}
\section{Відкрита та закрита модель ТЗ}

Модель ТЗ прийнято називати \emph{закритою}, якщо сума обсягів виробництва рівна сумі обсягів споживання, тобто виконується умова балансу мас. Якщо ж виконується якась із нерівностей, то модель ТЗ називається \emph{відкритою}.

Припустимо, що виконується $\sum_{i=1}^m a_i > \sum_{j=1}^n b_j$. В цьому випадку задача формулюється так:
Маємо $m$ пунктів виробництва однорідного продукту і $n$ пунктів споживання, відповідно із запасом $a_i, i=\overline{1,m}$ і потребами $b_j, j=\overline{1,n}$. Задається матриця вартостей перевезень $C=\{cij\}_{m,n}, c_{ij}$ – вартість перевезення одиниці продукту з $i$ в $j$. $x_{ij}$ – кількість продукту, який перевозиться з $i$ в $j$.
Слід знайти такий невідємний набір $x_{ij}$, щоб виконувались умови:
\[ \sum_{j=1}^n x_{ij} \leq a_i, i=\overline{1,m} \]
\[ \sum_{i=1}^m x_{ij} \leq b_j, j=\overline{1,n} \]
При цьому повинен досягатися $\min$ сумарних перевезень:
\[ L = \sum_{i=1}^m \sum_{j=1}^n c_{ij} x_{ij} \to \min \]

Для розвязування цієї задачі треба відкриту модель перетворити в закриту. В даному випадку це здійснюється так:
Вводимо $(n+1)$-й пункт призначення, який є фіктивним, з потребами $b_{n+1} = \sum_{i=1}^m a_i - \sum_{j=1}^n b_j$. При цьому вартості перевезень приймаються рівними $c_{1 n+1} = c_{2 n+2} = \dots = c_{m n+1}$.

Оскільки при рівних вартостях перевезень немає значення, від якого з пунктів виробництва буде скеровуватися продукція до пунктів споживання, то в результаті розв’язування задачі одержимо, що вартість перевезень реальним споживачам буде $\min$, а фіктивному споживачу буде скеровуватися продукція від найменш вигідних пунктів виробництва.

У випадку, коли $\sum_{i=1}^m a_i < \sum_{j=1}^n b_j$, вводимо фіктивний $(m+1)$-й пункт виробництва з обсягами $a_{m+1} = \sum_{j=1}^n b_j - \sum_{i=1}^m a_i$. Якщо нема значення, потреби якого із пунктів споживання не будуть повністю задоволені, то вартості перевезень від фіктивного пункту виробництва приймаються рівними. Якщо потреби якогось із пунктів споживання потрібно повністю задовільнити, то в клітину, що стоїть на перетині рядка з фіктивним пунктом виробництва і цим споживачем, ставиться найбільша вартість перевезення. У звязку з цим потреби цього пункту споживання будуть задоволені за рахунок реальних пунктів виробництва.

\section{Задача про призначення}

Нехай маємо $n$ робітників і $n$ робіт, причому кожен робітник може виконувати будь-яку, але одну роботу.

Задається матриця вартостей $C=[c_{ij}]_{n,n}, c_{ij}$ - наприклад, час виконання $i$-м робітником $j$-ї роботи. Позначимо через $x_{ij}$ змінну, яка = 1, якщо $i$-й робітник виконує $j$-у роботу і 0 - в протилежному випадку.

Потрібно так розприділити робітників на виконання робіт, щоб сімарний час виконання всіх робіт був найменший. Тоді математична модель задачі про призначення має наступний вигляд:
\[ \sum_{i=1}^n \sum_{j=1}^n c_{ij} x_{ij} \to \min \]
\[ \sum_{j=1}^n x_{ij} = 1, i = \overline{1,n} \]
\[ \sum_{i=1}^n x_{ij} = 1, j = \overline{1,n} \]
\[ x_{ij} = x_{ij}^2 \mbox{ або (що еквівалентно) } x_{ij} \in \{0,1\} \]
Якщо остатню умову замінити на $x_{ij} \geq 0$ то задачу про призначення можна розглядати як ТЗ при $a_i=1, i = \overline{1,n}, b_j=1, j = \overline{1,n}$.

Оскільки всі $a_i, b_j \in \mathbf{Z}$ то розв’язок також буде цілим.

Задача про призначення є повністю виродженим випадком ТЗ, а тому для її розв’язування розроблений більш ефектнивний метод ніж для розв’язування ТЗ. Цей метод базується на 2-х наступних теоремах.

\subsection{Теорема 1}

Якщо набір $x_{ij}, i,j=\overline{1,n}$ мінімізує лінійну форму $ L = \sum_{i=1}^n \sum_{j=1}^n c_{ij} x_{ij} $, за умов:
\[ \sum_{j=1}^n x_{ij} = 1, i = \overline{1,n},  \sum_{i=1}^n x_{ij} = 1, j = \overline{1,n}, \]
то він мінімізує і форму:
\[ L' = \sum_{i=1}^n \sum_{j=1}^n (c_{ij} - u_i - v_j) x_{ij}. \]

{\bf Доведення:}

\[ L' = \sum_{i=1}^n \sum_{j=1}^n (c_{ij} - u_i - v_j) x_{ij} = \]
\[ = \sum_{i=1}^n \sum_{j=1}^n c_{ij} x_{ij} - \sum_{i=1}^n \sum_{j=1}^n u_i x_{ij} - \sum_{i=1}^n \sum_{j=1}^n v_j x_{ij} = \]
\[ = L - \sum_{i=1}^n u_i (\sum_{j=1}^n x_{ij}) - \sum_{j=1}^n v_j (\sum_{i=1}^n x_{ij}) = \]
\[ = L - \sum_{i=1}^n u_i - \sum_{j=1}^n v_j \]

Оскільки два останні доданки не залежать від $x$ то мінімум $L$ і $L'$ досягається на тих самих наборах $x_{ij}$.

\subsection{Теорема 2}

Якщо всі $c_{ij} \geq 0$ і $ \sum_{i=1}^n \sum_{j=1}^n c_{ij} x_{ij} = 0$, то набір $x_{ij}$ є оптимальним планом.

{\bf Очевидно.}

\subsection{Алгоритм}

\begin{slim_enumerate}
  \item {\it Попередній крок.} Здійснюємо приведення матриці. В кожному рядку шукаєм мінімальний елемент і віднімаєм його від усіх елементів цього рядка. Аналогічно поступаємо із стовпчиками.
  \item {\it Загальний крок.} Мінімальний числом горизонтальних і вертикальних ліній перетинаємо всі нулі принаймі один раз.

Можна показати, що в матриці $n \times n$ можна перетяти всі нулі меншим числом ліній ніж $n$ тоді і лише тоді, коли серед нулів розв’язку нема. Таким чином, якщо всі нулі можна перетяти лише кількістю ліній, що рівна $n$ то маємо розв’язок і його знаходимо. Якщо кількість ліній менша ніж $n$ переходимо до кроку 3.

  \item {\it Перехід.} Серед незакреслених елементів шукаєм мінімальний і віднімаємо його від усіх незакреслених і додаємо до двічі закреслених. Переходимо до кроку 1.
\end{slim_enumerate}

\section{Метод диференціальних рент (розв’язування ТЗ)}

Зручний тим, що в процесі розв’язування ми не зустрічаємся з випадком виродженості.

Вважається що ТЗ задана таблицею.\\
\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
	&	\diagcell{4}{3}{}{2}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{1}	&	60\\
\hline
	&	\diagcell{4}{3}{}{2}	&	\diagcell{4}{3}{}{3}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{4}	&	70\\
\hline
	&	\diagcell{4}{3}{}{3}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{}{2}	&	\diagcell{4}{3}{}{5}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

В кожному стопці шукаємо мінімальну вартість перевезення і беремо її в кільце.

\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
	&	\diagcell{4}{3}{}{(2)}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{(1)}	&	60\\
\hline
	&	\diagcell{4}{3}{}{(2)}	&	\diagcell{4}{3}{}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{4}	&	70\\
\hline
	&	\diagcell{4}{3}{}{3}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{}{(2)}	&	\diagcell{4}{3}{}{5}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

Після цього здійснюємо розподіл, причому, заповнюємо тільки ті клітини, які відмічені кільцями. (Порівнюємо обсяг виробництва по відповідному рядку і обсяг споживання по відповідному стовпчику. Менший із порівнюваних обсягів приймаємо ща величину перевезення. Перевіряємо чи весь обсяг виробництва розподілений.)

\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
	&	\diagcell{4}{3}{40}{(2)}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{20}{(1)}	&	60\\
\hline
	&	\diagcell{4}{3}{}{(2)}	&	\diagcell{4}{3}{30}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{4}	&	70\\
\hline
	&	\diagcell{4}{3}{}{3}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{20}{(2)}	&	\diagcell{4}{3}{}{5}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

Якщо запас пункту виробництва вичерпаний, а потреби пунктів споживання зв’язаних кільцем з цим пунктом виробництва не є повністю задоволені, то пункт виробництва вважається недостатнім, а рядок \emph{від’ємним}.

Якщо ж в пукнті виробництва є нерозподілений залишок, а всі пункти споживання, пов’язані кільцем із цим пунктом виробництва, є повністю задоволені то пункт вважається надлишковим, а рядок \emph{додатним}.

\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
-30	&	\diagcell{4}{3}{40}{(2)}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{20}{(1)}	&	60\\
\hline
+40	&	\diagcell{4}{3}{}{(2)}	&	\diagcell{4}{3}{30}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{4}	&	70\\
\hline
-10	&	\diagcell{4}{3}{}{3}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{20}{(2)}	&	\diagcell{4}{3}{}{5}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

Якщо не розподілений залишок по рядку є 0, то якщо цей рядок кільцем пов’язаний із додатнім рядком, то знак „$+$“, якщо з від’ємним - „$-$“. Якщо одночасно пов’язаний із від’ємним і додатнім то у відповідному пункті виробництва збільшуємо обсяг виробництва і здійснюємо після цього розподіл. Якщо обсяг поставок, по цьому рядку збільшиться то ставим „$-$“, якщо не - „$+$“.

Надлишок чи недостачу у кожному рядку записуємо зліва у рядку з відповідним знаком.

Наступний етап розв’язування полягає у визначення різниць між найменшою вартістю у додатньому рядку і вартістю у кільці. Ці числа записуємо в додатковому рядку на відповідними стовпчиками.

\emph{Зауважимо.} Якщо кільце стоїть у додатньому рядку, то різниця не обчислюється.

Серед отриманих різниць шукаєм мінімальну, яка називається \emph{проміжна рента} і позначається $d$.

\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&	-	&	-	&	7	&	3	&	$d=3$\\
\hline
-30	&	\diagcell{4}{3}{40}{(2)}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{20}{(1)}	&	60\\
\hline
+40	&	\diagcell{4}{3}{}{(2)}	&	\diagcell{4}{3}{30}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{4}	&	70\\
\hline
-10	&	\diagcell{4}{3}{}{3}	&	\diagcell{4}{3}{}{4}	&	\diagcell{4}{3}{20}{(2)}	&	\diagcell{4}{3}{}{5}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

Переходимо до наступної таблиці. До вартостей перевезень у від’ємних рядках додаємо величину проміжної ренти, а вартості у додатніх - не змінюємо.

\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{8}	&	\diagcell{4}{3}{}{4}	&	60\\
\hline
	&	\diagcell{4}{3}{}{2}	&	\diagcell{4}{3}{}{3}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{4}	&	70\\
\hline
	&	\diagcell{4}{3}{}{6}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{8}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

Знову в кожному стовпці шукаємо мінімальну вартість.

\emph{Зауважимо.} В стовпчику, якому відповідала проміжна рента з’являється ще один мінімальний елемент. Ще мінімальний елемент, в деяких випадках, може появитись в стовпчиках, яким відповідає проміжна рента.

\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{8}	&	\diagcell{4}{3}{}{(4)}	&	60\\
\hline
	&	\diagcell{4}{3}{}{(2)}	&	\diagcell{4}{3}{}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{(4)}	&	70\\
\hline
	&	\diagcell{4}{3}{}{6}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{(5)}	&	\diagcell{4}{3}{}{8}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

Після цього здійснюється розподіл обсягу вироництв. Оскільки тепер більше елементів в кільці ніж рядків, то розподіл здійснюється по іншому.

Починаємо перегляд по рядках або по стовпчиках, при цьому заповнюємо клітину з кільцем лише тоді, коли вона є єдиною відміченою клітиною в своєму рядку, якщо перегляд по рядках і в стовпці - якщо по стовпцях. При повторному перегляді заповнена клітина вже не враховується.

(Спочатку по рядках)
\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{8}	&	\diagcell{4}{3}{50}{(4)}	&	60\\
\hline
	&	\diagcell{4}{3}{}{(2)}	&	\diagcell{4}{3}{}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{(4)}	&	70\\
\hline
	&	\diagcell{4}{3}{}{6}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{20}{(5)}	&	\diagcell{4}{3}{}{8}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

(Потім по стовпцях)
\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{8}	&	\diagcell{4}{3}{50}{(4)}	&	60\\
\hline
	&	\diagcell{4}{3}{40}{(2)}	&	\diagcell{4}{3}{30}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{(4)}	&	70\\
\hline
	&	\diagcell{4}{3}{}{6}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{20}{(5)}	&	\diagcell{4}{3}{}{8}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

Знову обчилюємо в кожному рядку недостачу чи надлишок, присвоюєм відповідні знаки, обчислюємо величину проміжної ренти $d$ і переходимо до наступної таблиці. Продовжуємо до того часу, поки нерозподілений залишок стане рівний нулю.

\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&	-	&	-	&	3	&	-	&	$d=3$\\
\hline
+10	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{8}	&	\diagcell{4}{3}{50}{(4)}	&	60\\
\hline
+0	&	\diagcell{4}{3}{40}{(2)}	&	\diagcell{4}{3}{30}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{(4)}	&	70\\
\hline
-10	&	\diagcell{4}{3}{}{6}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{20}{(5)}	&	\diagcell{4}{3}{}{8}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}
$\rightarrow$
\begin{tabular}{ | c | c | c | c | c | c | }
\hline
	&		&		&		&		&\\
\hline
	&	\diagcell{4}{3}{}{5}	&	\diagcell{4}{3}{}{7}	&	\diagcell{4}{3}{}{8}	&	\diagcell{4}{3}{50}{(4)}	&	60\\
\hline
	&	\diagcell{4}{3}{40}{(2)}	&	\diagcell{4}{3}{30}{(3)}	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{(4)}	&	70\\
\hline
	&	\diagcell{4}{3}{}{9}	&	\diagcell{4}{3}{}{10}	&	\diagcell{4}{3}{20}{(8)}	&	\diagcell{4}{3}{}{11}	&	20\\
\hline
	&	40	&	30	&	30	&	50	&\\
\hline
\end{tabular}

\section{Транспортна задача за критерієм часу}

Виникає тоді, коли вартість перевезення не є істостною, а першочергове значення має час, за який здійснюється перевезення. Наприклад, приперевезенні товарів, які швидко псуються.

{\bf Задача}

Нехай маємо $m$ пунктів виробництва однорідного продукту з обсягами $a_i, i = \overline{1,m}$ і $n$ пунктів споживання з потребами $b_j, j= \overline{1,n}$. При цьому, $\sum_{i=1}^m a_i = \sum_{j=1}^n b_j$. Задається матриця $T=[t_{ij}]_{m,n}, t_{ij}$ - час перевезення продукту з пункту постачання $i$ в пункт споживання $j$.

Потрібно знайти такий набір $x_{ij} \geq 0, i = \overline{1,m}, j = \overline{1,n}$, де $x_{ij}$ - кількість продукту, яка перевозиться із $i$ в $j$,щоб виконувались наступні умови:
\begin{slim_enumerate}
  \item $ \sum_{j=1}^n x_{ij} = a_i, i = \overline{1,m} $
  \item $ \sum_{i=1}^m x_{ij} = b_j, j = \overline{1,n} $
  \item Допустимий план $x_{ij}$ повинен бути оптимальний по часу.
\end{slim_enumerate}

З кожним допустимим планом $x=\{x_{ij}\}_{m,n}$ пов’язаний набір $\{t_{ij}\}_x$, прицьому елемент матриці $T$ належить цьому набору $t_{ij} \in \{t_{ij}\}_x$, якщо $x_{ij}>0$.

Тоді $t_x = \max \{t_{ij}\}_x$ - час за який привозиться $x$.

Тоді умова 3) запишеться у вигляді:
\[ t^*=\displaystyle\min_x \max \{t_{ij}\}_x \]

План $x$, для якого виконується така умова є оптимальним по часу.

\subsection{Алгоритм розв’язування ТЗ за критерієм часу}
\begin{slim_enumerate}
  \item {\it Початковий крок.} Яким-небудь із способів будуємо початковий опорний план $x_0$.\\
\begin{tabular}{ | c | c | c | c | c | }
\hline
$11/1^-$	&	7/3	&	$/7^+$	&\cellcolor[rgb]{0.8,0.8,0.8}	/12	&	18\\
\hline
$/2^+$	&	2/8	&	$8/10^-$	&	/8	&	10\\
\hline
/6	&	/1	&	5/4	&	7/5	&	12\\
\hline
11	&	9	&	13	&	7	&\\
\hline
\end{tabular}
- будуємо початковий опорний план методом Пн-Зх кута.

  \item {\it Загальний крок.} Визначимо $t'=\displaystyle\max_{x_{ij}>0}\{t_{ij}\}$.

Закреслюємо всі вільні клітини, для яких $t_{ij} \geq t'$.

\begin{tabular}{ | c | c | c | c | c | }
\hline
$11/1^-$	&	7/3	&	$/7^+$	&\cellcolor[rgb]{0.8,0.8,0.8}	/12	&	18\\
\hline
$/2^+$	&	2/8	&	$8/10^-$	&	/8	&	10\\
\hline
/6	&	/1	&	5/4	&	7/5	&	12\\
\hline
11	&	9	&	13	&	7	&\\
\hline
\end{tabular}
$t'=10$\\

Будемо покращувати план $x_0$. Стараємося перевезення $x'_{ij}$, що відповідає $t'$, по можливості, зробити нулем. Це дає змогу отримати оптимальний план за меншу кількість кроків.

Для заповнення клітини, що відповідає $t'$ будуємо ланцюжок (замкнутий контур) починаючи із цієї клітини, якій присвоюємо знак "$-$", при цьому, від’ємними беремо клітини з $x_{ij}>0$, а додатними з $t_{ij}<t'$.

{\it Зауважимо.} Це відбувається так як і в методі потенціалів. Серед від’ємних клітин шукаємо мінімальне перевезення і віднімаєм від від’ємних і додаєм до додатніх.

Переходим до наступної транспортної таблички.\\
\begin{tabular}{ | c | c | c | c | c | }
\hline
$3/1^-$	&	$7/3^+$	&	8/7	&\cellcolor[rgb]{0.8,0.8,0.8}	/12	&	18\\
\hline
$8/2^+$	&	$2/8^-$	&\cellcolor[rgb]{0.8,0.8,0.8}	/10	&\cellcolor[rgb]{0.8,0.8,0.8}	/8	&	10\\
\hline
/6	&	/1	&	5/4	&	7/5	&	12\\
\hline
11	&	9	&	13	&	7	&\\
\hline
\end{tabular}
$t'=8$\\

Повторюємо загальний крок до того часу, поки не можливо буде побудувати потрібний ланцюжок. Тоді останнє $t'=t^*$ - мінімальний час перевезення, а останній план - оптимальний.\\
\begin{tabular}{ | c | c | c | c | c | }
\hline
1/1	&	9/3	&	$8/7^-$	&\cellcolor[rgb]{0.8,0.8,0.8}	/12	&	18\\
\hline
10/2	&\cellcolor[rgb]{0.8,0.8,0.8}	/8	&\cellcolor[rgb]{0.8,0.8,0.8}	/10	&\cellcolor[rgb]{0.8,0.8,0.8}	/8	&	10\\
\hline
/6	&	/1	&	5/4	&	7/5	&	12\\
\hline
11	&	9	&	13	&	7	&\\
\hline
\end{tabular}

Оскільки ми не можем побудувати ланцюжок - то $t^*=7$, а план $x_{11},x_{12},x_{13},x_{21},x_{33},x_{34}$ - оптимальний.
\end{slim_enumerate}

\section{Задача про максимальний потік}

Нехай на площині маємо $n+2$ точки $P_0, P_1, \dots, P_{n+1}$, при цьому деякі впорядковані пари $P_i, P_j$ з’єднані ланкою $(P_i, P_j)$ так, що утворюють зв’язний ланцюг (сітку).

Ланки $(P_i, P_j), (P_j, P_i)$ - симетричні.

По шляхах $\mu(P_0, P_{i_1}, P_{i_2}, \dots, P_n, P_{n+1})$, що складаються із ланок \[(P_0, P_{i_1}), (P_{i_1}, P_{i_2}), \dots, (P_n, P_{n+1})\] і не утворюють петель, рідина, газ або транспорт із точки $P_0$ - входу сітки, поступає в $P_{n+1}$ - вихід сітки.

Кожній ланці $(P_i, P_j)$ ставиться у відповідність число $a_{ij} \geq 0$, яке називається \emph{пропускною здатністю ланки} і означає кількість речовини, яку може пропустити ця ланка за одиницю часу.

\emph{Потоком} $x_{ij}$ \emph{по ланці} $(P_i, P_j)$ називають кількість речовини, яка проходить по цій ланці за одиницю часу.

Вважаємо (логічно), що потоки задовільнають умовам:
\begin{equation} 0 \ leq x_{ij} \leq a_{ij}, i,j = \overline{0, n+1}; \label{eq:flowvol} \end{equation}
\begin{equation} \sum_{k=0}^n x_{ki} = \sum_{k=1}^{n+1} x_{ik}, i = \overline{1, n}; \label{eq:flowbalance} \end{equation}

Умова (\ref{eq:flowvol}) означає, що величина потоку в ланці не може перевищувати пропускної здатності цієї ланки.

Умова (\ref{eq:flowbalance}) означає, що кількість речовини, яка поступає в будь-яку точку сітки, крім $P_0$-входу і $P_{n+1}$-виходу сітки збігається із кількістю речовини, яка виходить із цієї точки.

З (\ref{eq:flowbalance}) випливає:
\begin{equation} \sum_{i=1}^{n+1} x_{0 i} = \sum_{i=0}^{n} x_{i n+1} = Z \label{eq:flowlineform} \end{equation}

Лінійна форма $Z$ називається \emph{величиною потоку в сітці}.

Ставиться задача знайти величину максимального потоку в сітці, тобто знайти такий набір $x_{ij}^*$, який задовольняє (\ref{eq:flowvol}),(\ref{eq:flowbalance}) і максимізує лінійну форму (\ref{eq:flowlineform}).

{\it Зауважимо.} Задача (\ref{eq:flowvol} - \ref{eq:flowlineform}) є задачею лінійного програмування і, взагалі кажучи, може бути розв’язана симплекс методом.

Перш ніж розглядати більш ефективний алгоритм введемо деякі попередні поняття.

Всі точки сітки розіб’ємо на дві множини $U, V$, які не перетинаються і $P_0 \in U, P_{n+1} \in V$.

Розглянемо множину ланок, що виходять із $U$ і входять у $V$ і назвемо її \emph{перерізом сітки}, позначимо $(U, V)$.

\emph{Пропускною здатністю перерізу} називається величина
\begin{equation} A(U, V) = \sum_{P_i \in U, P_j \in V} a_{ij}. \end{equation}

Очевидно, що для довільного потоку $Z$ і довільного перерізу $(U, V)$ виконується $Z \leq A(U, V)$.

Переріз із найменшою пропускною здатністю називається \emph{мінімальним перерізом}.

\subsection{Алгоритм}

\begin{slim_enumerate}
  \item {\it Попередній крок.} Записати умови задачі табличкою:\\
\begin{tabular}{ | c | c | c | c | c | c | c | c | }
\hline
	&	$P_0$	&	$\dots$	&	$P_i$	&	$\dots$	&	$P_j$	&	$\dots$	&	$P_{n+1}$\\
\hline
$P_0	$&		&		&	$a_{0 i}$	&		&	$a_{0 j}$	&		&	$a_{0 n+1}$\\
\hline
$\vdots$	&		&		&		&		&		&		&\\
\hline
$P_i$	&	$a_{i 0}$	&		&		&		&		&		& $a_{i n+1}$\\
\hline
$\vdots$	&		&		&		&		&		&		&\\
\hline
$P_j$	&	$a_{j 0}$	&		&		&		&		&		& $a_{j n+1}$\\
\hline
$\vdots$	&		&		&		&		&		&		&\\
\hline
$P_{n+1}$	&	$a_{n+1 0}$	&		&	$a_{n+1 i}$	&		&	$a_{n+1 j}$	&		&\\
\hline
\end{tabular}

В клітину $(P_i, P_j)$ проставити пропускні здатності $a_{ij}>0$. Якщо $a_{ij}=0$ то цей 0 записуєм в таблицю, а якщо $P_l, P_m$ не з’єднані ланкою, то $a_{l m} = 0$, але цей 0 не заповнюється, всі $a_{ii}=0$ теж не заповнюються.

Задача полягає у відшуканні всіх можливих шляхів із $P_0$ в $P_{n+1}$ і знаходженні їх пропускних здатностей.

  \item {\it Загальний $k$-й крок.}
  \begin{slim_enumerate}
    \item {\it Відшукання шляху з одночасним визначенням його пропускної здатності.}

Так як, шукаєм шлях від початкової вершини $P_0$, то біля $P_0$ і в рядку і в стовпці записуєм * - позначення.
    \begin{slim_enumerate}
      \item По відміченому рядку довільно вибираєм комірку, в якій значення відмінне від нуля $(a_{0 i_0} \neq 0)$, і стовпчику цієї комірки присвоюєм мітку $(0, h_{i_0})$, де перше значення - вершина з якої прийшли (рядок в якому шукали, $P_0$), друге - пропускна здатність шляху по якому йдем, так як це перша ланка шляху, то поки пропускна здатність шляху = пропускній здатності ланки $(h_{i_0}=a_{0 i_0})$.
      \item Аналогічне позначення пишем в рядку, що відповідає даному стовпцю. В цьому рядку повторюєм крок {\bf 3.a.} - шукаєм комірку зі значенням відмінним від нуля $(a_{i_0 j} \neq 0)$. Стовпцю вибраної комірки $(a_{i_0 j})$ знову присвоюємо мітку $(i_0, h_j)$, де $i_0$ - знову, вершина з якої прийшли (рядок в якому шукали), а $h_j$ - пропускна здатність шляху $= \min \{h_{i_0}, a_{i_0 j}\}$ - тобто менше між пропускною здатністю попередньої частини шляху і пропускною здатністю даної ланки.
      \item Продовжуємо поки не знайдем шлях між $P_0$ і $P_{n+1}$, тобто не надпишем мітку над стовпчиком з останньою вершиною. Далі виписуєм цей шлях $(\mu_k(P_0, \dots , P_{n+1}), k \mbox{ - лічильник шляхів})$ і його пропускну здатність - $\theta_k=h_{n+1}$ - значення з останньої мітки.

Якщо процес відмічання неможливо продовжити - тобто не існує більше шляхів із $P_0$ в $P_{n+1}$ - алгоритм закінчує свою роботу.
    \end{slim_enumerate}
  \item {\it Визначення нових пропускних здатностей ланок знайденого шляху та симетричних з ними.}

По мітках стовпців знаходимо комірки, по яких ми „пройшлись“ і проставляєм позначки „$-$“, а в симетричних до них - „$+$“. Від значень в комірках з „$-$“ віднімаєм пропускну здатність знайденого шляху ($\theta_k$), а до значень в комірках з „$+$“ додаєм. Отримали нову табличку вертаємся до кроку {\bf (a.i)}.
  \end{slim_enumerate}
\end{slim_enumerate}

Для визначення величини потоків по ланках від елементів вихідної таблиці віднімаємо відповідні елементи останньої таблиці. Додатні значення різниць і є величинами потоків по шляхах.

\subsection{Теорема Форда-Фалкерсона.}

Величина максимального потоку в сітці не перевищує пропускної здатності мінімального перерізу, причому існує потік величина якого рівна пропускній здатності мінімального перерізу.

{\bf Доведення.}

Покажемо, що якщо по ланці є потік, то по симетричній ланці немає потоку.

Припустимо, що по ланці $(P_i, P_j)$ є потік $x_{ij}>0$. нехай сумарна кількість речовини, що проходить по ланці $(P_i, P_j)$ становить $\theta'$. Тоді пропускна здатність цієї ланки становить $a_{ij} - \theta'$, а симетричної до неї: $a_{ji} + \theta'$.

Припустимо, що кількість речовини, що проходить через $(P+j, P_i)$ становить $\theta''$, тоді пропускна здатність $(P_j, P_i)$ становить $a_{ji}+\theta'-\theta''$, а $(P_i, P_j)$: $a_{ij}-\theta'+\theta''$.

Тим самим, отримуємо:
\[ x_{ij} = a_{ij} - (a_{ij} - \theta' + \theta'') = \theta' - \theta'' > 0 \]
\[ x_{ji} = a_{ji} - (a_{ji} + \theta' - \theta'') = \theta'' - \theta' < 0 \mbox{, що неможливо.}\]

Покажемо, що отримана з алгоритму величина потоку по сітці - оптимальна.

Алгоритм закінчує роботу, якщо ми не можем знайти нового шляху із $P_0$ в $P_{n+1}$, тобто отримуємо таблицю, в якій наможливо продовжити процес мічення. Розіб’ємо точки сітки на дві підмножити $U^*, V^*$, тобто будуємо переріз $(U^*, V^*)$ наступним чином: $P_0 \in U^*$, вершина $P_k \in U^* \Leftrightarrow$ її можня досягти із т. $P_0$, тобто $\exists \mu(P_0, P_{i_1}, \dots, P_k)$. Всі решта точок віднесемо до $V^*$, отже $P_{n+1} \in V^*$.

Розглянемо ланку $(P_i, P_j): P_i \in U^*, P_j \in V^*$. Отримуємо: $x_{ij}=a_{ij}$ і $x_{ji}=0$ або $x_{ij}=0$, оскільки $a_{ij}=0, a_{ji} \neq 0$, але ланка $(P_j, P_i)$ не використовується.

Звідси отримуємо, що: 
\[ Z= \sum_{P_i \in U^*, P_j \in V^*} a_{ij}, \]
з другого боку
\[ A(U^*, V^*) = \sum_{P_i \in U^*, P_j \in V^*} a_{ij}. \]
Оскільки для довільного потоку і перерізу справедливо $Z \leq A(U, V)$, то отримуємо, що 
\[ Z = A(U^*, V^*), \]
\[ Z^*=Z, x_{ij}^*=x_{ij}, \]
\[ Z^*=\min_{(U,V)} A(U,V). \mbox{ Доведено.}\]

\section{Задача комівояжера}

Комівояжер повинен побувати в ряді міст. Задаються віддалі, час або вартість проїзду між кожною парою міст. Комівояжер повинен, відповідно, вибрати найкоротний, найменш тривалий, найдешевший, замкнутий маршрут, який 1 раз проходить через кожне місто і завершується в початковому. Якщо віддалі, час або вартість не залежать від напрямку руху, то така задача є \emph{симетрична}.

Нехай $S(0)$ - множина всіх допустимих замкнутих маршрутів (циклів) задачі комівояжера $n \times n$ з матрицею витрат $[c_{ij}]$. $S(0)$ складається з $(n-1)!$ циклів.

Здійснимо зведення матриці витрат, аналогічно як і в задачі про призначення. В наслідок цього в кожному ряку і кожному стовпчику матриці буде 1 нульовий елемент. Якщо серед нулів можна знайти замкнутий маршрут, то він і буде оптимальним. а його вартість рівна сумі звідних констант. Звідси отримуєм, що вартість довільного циклу із множини $S(0)$ не є маншою ніж сума звідних констант. Позначимо суму звідних констант через $r$ і це число буде нижньою оцінкою множини $S(0)$.

Метод гілок та меж полягає в наступному: множина $S(0)$ розбивається на 2 підмножини, що не перетинаються і обчислюються нижні оцінки кожної з підмножин.

Підмножина, оцінка якої менша, відбирається для наступного розгалуження і т.д. поки не отримаєм розв’язок задачі.

\subsection{Алгоритм}

\begin{slim_enumerate}
  \item {\it Зведення матриці.} В кожному рядку матриці знайти найменше значення (звідна константа) і відняти його від усіх елементів рядка. Аналогічно робим зі стовпчиками.

Отримали зведену матрицю $[c'_{ij}]$, в кожному рядку і кожному стовпці якої маємо принаймі один нуль.

Обчислюємо суму звідних констант r.

  \item Для кожного нульового елемента матриці $[c'_{ij}]$ обчислити штраф за невикористання.

Нехай $(h,k)$ - нульовий елемент. Якщо ребро $(h,k)$ не використовується, то в маршрут обов’язково повинне ввійти ребро, яке виходить з $h$ і ребро, яке заходить в $k$. Тому штраф за невикористання $P_{h k}$ складе не меншне ніж сума мінімального елемента рядка h і мінімального елемента стовпчика k.
\[ P_{h k} = \displaystyle\min_{i \neq h}\{c'_{i k}\} + \displaystyle\min_{j \neq k}\{c'_{h j}\} \]
Штраф записуєм злів зверху кожного нуля.

  \item Вибираєм клітину з найбільшим штрафом (якщо декілька - вибираєм довільно). Припустимо це клітина $(h, k)$. 

Розбиваємо вибрану множину (на {\bf першій ітерації} це множина всіх штрафів - $S(0)$) на дві підмножини, що не перетинаються: $S(h,k)$ - містить $(h,k)$ і $S \overline{(h,k)}$ - не містить ребра $(h, k)$.

  \item Обчислюємо нижні оцінки кожної із підмножин. Нехай $\theta'$ - нижня оцінка множини, яка розбивається (на {\bf першій ітерації} це - $r$).
  \begin{slim_enumerate}
    \item Обчислимо нижню оцінку множини $S \overline{(h,k)}$.

Як вже вказувалось, якщо маршрут не містить ребра $(h,k)$ то додаткові затрати складуть на менше ніж $P_{h k}$, крім суми звідних констант $r$. Отже:
\[ \theta \overline{(h,k)} = \theta'+P_{h k}. \]
    \item Обчислюємо нижню оцінку $S(h,k)$.
    \begin{slim_enumerate}
      \item Якщо $(h,k)$ входить то жодне інше ребро, що починається в $h$ і жодне інше ребро, що входить в $k$ не може входити в маршрут. Тому рядок $h$ і стовпчик $k$ викреслюються.
      \item {\bf На першій ітерації.} Якщо входить ребро $(h,k)$ то ребро $(k,h)$ не може входити, тому $c'_{k h} = \infty$.

{\bf На всіх подальших ітераціях.} Шукаємо елемент $(\alpha, \beta)$, який із $(h,k)$ і раніше включеними в цикл ребрами утворює замкнутий підцикл і, відповідно, вартість $c'_{\alpha \beta}$ приймаємо рівною $\infty$.

      \item Зводимо матрицю, якщо потрібно і обчислюєм суму звідних констант $r_{h k}$.
      \item $ \theta(h,k) = \theta' + r_{h k} $
    \end{slim_enumerate}
  \end{slim_enumerate}
  \item Для наступного розгалуження вибираємо підмножину з меншою оцінкою.
  \begin{slim_enumerate}
    \item Якщо $\theta\overline{(h,k)} < \theta(h,k)$ то вибираємо множину $S\overline{(h,k)}$ і повертаємося до кроку {\bf 2} з матрицею (отриманою до кроку {\bf 4}) $[c'_{ij}], c'_{h k}=\infty$ і отриману матрицю, якщо потрібно зводимо.
    \item Якщо $\theta\overline{(h,k)} > \theta(h,k)$ то обираємо $S(h,k)$ і повертаємося до кроку {\bf 2} з матрицею отриманою по кроці {\bf 4}).
  \end{slim_enumerate}
\end{slim_enumerate}

\chapter{Основи мережевого планування}
\section{Часові параметри детермінованих сіток (мереж)}
\section{Ранні та пізні строки початку та закінчення робіт}
\section{Резерви часу шляхів та робіт}
\chapter{Теорія ігор}
\section{Класифікація ігор}
\section{Максимільні теореми}
\subsection{Теорема 1}
\subsection{Теорема 2}
\section{*Шось про мішані стратегії*}
\subsection{Теорема 1}
\section{Властивості оптимальних мішаних стратегій}
\subsection{Теорема 2}
\subsection{Наслідок}
\subsection{Теорема 3}
\section{Спрощення ігор}
\subsection{Теорема 4}
\subsection{Теорема 5}
\section{Розв’язування матричних ігор 2х2}
\section{Розв’язування матричних ігор 2xn}
\section{Розв’язування матричних ігор mх2}
\section{Розв'язування матричних ігор шляхом зведення до задач лінійного програмування.}

Нехай маємо матричну гру з матрицею виграшів І-го гравця.\\
\\
$A =$
\begin{tabular}{|c|c|c|}
\hline
$a_{1 1}$&$\dots$&$a_{1 n}$\\
\hline
$\vdots$&&$\vdots$\\
\hline
$a_{m 1}$&$\dots$&$a_{m n}$\\
\hline
\end{tabular}

\subsection{I спосіб.}

Припустимо, що ціна гри $v$ – додатня, це завжди можна припускати, згідно теореми про спрощення матриці ігор, завжди можна підібрати таке $c>0$, додаючи яке до всіх елементів матриці $А$ отримаємо матрицю з додатніми елементами і додатною ціною гри, при цьому оптимальна мішана стратегія не змінюється. 

Із наслідку до теореми про критерій оптимальності мішаних стратегій отримуємо, що відшукання оптимальної мішаної стратегії зводиться до розвязку задач:
\begin{equation}
\begin{array}{l}
\displaystyle \sum_{i=1}^m x_i = 1, x_i \geq 0, i=\overline{1,m};\\
\displaystyle \sum_{i=1}^m a_{ij} x_i \geq v,  j=\overline{1,n}
\end{array}
\label{eq:mgtolp1p}
\end{equation}

\begin{equation}
\begin{array}{l}
\displaystyle \sum_{j=1}^n y_j = 1, y_j \geq 0, j=\overline{1,n};\\
\displaystyle \sum_{j=1}^n a_{ij} y_j \geq v,  i=\overline{1,m}
\end{array}
\label{eq:mgtolp2p}
\end{equation}

Оскільки за припущенням $v>0$  поділимо (\ref{eq:mgtolp1p}) і (\ref{eq:mgtolp2p}) на $v$ і введемо позначення:
\[ \displaystyle p_i=\frac{x_i}{v},  i=\overline{1,m}; q_i=\frac{y_i}{v},  j=\overline{1,n} \]
Тоді задача (\ref{eq:mgtolp1p}) запишеться ось так:
\begin{equation}
\begin{array}{l}
\displaystyle \sum_{i=1}^m p_i = \frac{1}{v}, p_i \geq 0, i=\overline{1,m};\\
\displaystyle \sum_{i=1}^m a_{ij} p_i \geq 1,  j=\overline{1,n}
\end{array}
\label{eq:mgtolp1p2}
\end{equation}

Оскільки мета першого гравця – максимально збільшити свій виграш $v$, то задача (\ref{eq:mgtolp1p2}) зводиться до наступної задачі лінійного програмування:
\begin{equation}
\begin{array}{l}
\displaystyle \sum_{i=1}^m p_i = \to \min,\\
\displaystyle \sum_{i=1}^m a_{ij} p_i \geq 1,  j=\overline{1,n}\\
p_i \geq 0, i=\overline{1,m}
\end{array}
\label{eq:mgtolp1p3}
\end{equation}

Для задачі (\ref{eq:mgtolp2p}) отримаємо:
\begin{equation}
\begin{array}{l}
\displaystyle \sum_{j=1}^n q_i = \frac{1}{v}, q_j \geq 0, j=\overline{1,n};\\
\displaystyle \sum_{j=1}^n a_{ij} q_i \geq 1,  i=\overline{1,m}
\end{array}
\label{eq:mgtolp2p2}
\end{equation}

Оскільки мета 2-го гравця максиgit pu	мально зменшити виграш першого, то задача зводиться до задачі лінійного програмування:
\begin{equation}
\begin{array}{l}
\displaystyle \sum_{j=1}^m q_j = \to \max, q_j \geq 0, j=\overline{1,n}\\
\displaystyle \sum_{j=1}^n a_{ij} q_j \geq 1,  i=\overline{1,m}
\end{array}
\label{eq:mgtolp2p3}
\end{equation}

Задачі (\ref{eq:mgtolp1p3}) і (\ref{eq:mgtolp2p3}) є взаємно двоїстими задачами лінійного програмування, які наприклад можна розв’язати симплекс–методом.

\subsection{ІІ спосіб.}

В цьому випадку ціна гри $v$ – довільна. Згідно з наслідку теореми про критерій оптимальності мішаних стратегій розв’язок матриці зводиться до розвязку задач:
\begin{equation}
\begin{array}{l}
\displaystyle \sum_{i=1}^m a_{ij} x_i \geq v,  j=\overline{1,n},\\
\displaystyle \sum_{i=1}^m x_i = 1, x_i \geq 0, i=\overline{1,m};
\end{array}
\label{eq:mgtolp2w1p}
\end{equation}

\begin{equation}
\begin{array}{l}
\displaystyle \sum_{j=1}^n a_{ij} y_j \geq v,  i=\overline{1,m},\\
\displaystyle \sum_{j=1}^n y_j = 1, y_j \geq 0, j=\overline{1,n};
\end{array}
\label{eq:mgtolp2w2p}
\end{equation}

Зведемо (\ref{eq:mgtolp2w1p}) до канонічної форми: введемо до кожної нерівності додаткову змінну $x_{m+j} \geq 0$:
\[ \begin{array}{l}
\displaystyle \sum_{i=1}^m a_{ij} x_i  - x_{m+j} = v,  j=\overline{1,n},\\
\displaystyle \sum_{i=1}^m x_i = 1, x_i \geq 0, i=\overline{1,m+n};
\end{array} \]

Виділимо першу рівність при $j=1$ і віднімемо її від решти:
\begin{equation} \sum_{i=1}^m a_{i 1} x_i  - x_{m+1} = v, \label{eq:mgtolp2w1p21} \end{equation}
\begin{equation}
\begin{array}{l}
\displaystyle \sum_{i=1}^m (a_{ij} - a_{i 1}) x_i  - x_{m+j} + x_{m+1} = 0,  j=\overline{2,n},\\
\displaystyle \sum_{i=1}^m x_i = 1,\\
x_i \geq 0, i=\overline{1,m+n};
\end{array}
\label{eq:mgtolp2w1p22}
\end{equation}

Отже задача (\ref{eq:mgtolp2w1p}) зводиться до наступної задачі лінійного програмування: знайти $\max$ лінійної форми (\ref{eq:mgtolp2w1p21}) при обмеженнях (\ref{eq:mgtolp2w1p22}).

Аналогічно поступаємо із задачею (\ref{eq:mgtolp2w2p}) ввівши додаткову змінну $y_{n+i} \geq 0$:
\[ \begin{array}{l}
\displaystyle \sum_{j=1}^n a_{ij} y_j + y_{n+i} = v,  i=\overline{1,m},\\
\displaystyle \sum_{j=1}^n y_j = 1, y_j \geq 0, j=\overline{1,m+n};
\end{array} \]

Виділимо першу рівність при $i=1$ і віднімемо її від решти:
\begin{equation} \sum_{j=1}^n a_{1 j} y_j  - y_{n+1} = v, \label{eq:mgtolp2w2p21} \end{equation}
\begin{equation}
\begin{array}{l}
\displaystyle \sum_{j=1}^n (a_{ij} - a_{1 j}) y_j  + y_{n+i} - y_{n+1} = 0,  i=\overline{2,m},\\
\displaystyle \sum_{j=1}^n y_j = 1,\\
y_j \geq 0, i=\overline{1,m+n};
\end{array}
\label{eq:mgtolp2w2p22}
\end{equation}

Отже задача (\ref{eq:mgtolp2w2p}) зводиться до наступної задачі лінійного програмування: знайти $\min$ лінійної форми (\ref{eq:mgtolp2w2p21}) при обмеженнях (\ref{eq:mgtolp2w2p22}).

\section{Біматрична гра.}

\emph{Біматрична гра} - це гра двох гравців з ненульовою сумою. Виграш кожного з гравців задається за допомогою матриці. Нехай перший гравець має $m$ стратегій, а другий - $n$. Виграші першого і другого гравця задаються відповідно матрицями A, B:\\
$A =$
\begin{tabular}{|c|c|c|}
\hline
$a_{1 1}$&$\dots$&$a_{1 n}$\\
\hline
$\vdots$&&$\vdots$\\
\hline
$a_{m 1}$&$\dots$&$a_{m n}$\\
\hline
\end{tabular}\\
$B =$
\begin{tabular}{|c|c|c|}
\hline
$b_{1 1}$&$\dots$&$b_{1 n}$\\
\hline
$\vdots$&&$\vdots$\\
\hline
$b_{m 1}$&$\dots$&$b_{m n}$\\
\hline
\end{tabular}

Будемо вважати мішаною стратегією першого гравця:
\[\begin{array}{l}
x = (x_1, \dots, x_m)\\
\sum_{i=1}^m x_i = 1, x_i \geq 0, i = \overline{1,m}
\end{array}\]

Другого:
\[\begin{array}{l}
y = (y_1, \dots, y_n)\\
\sum_{j=1}^n y_j = 1, y_j \geq 0, j = \overline{1,n}
\end{array}\]

Тоді середні виграші обох гравців будуть:\\
Першого: $\displaystyle H_1=H(A,y,x)=\sum_{i=1}^m \sum_{j=1}^n a_{ij} x_i y_j$\\
Другого: $\displaystyle H_2=H(B,y,x)=\sum_{i=1}^m \sum_{j=1}^n b_{ij} x_i y_j$

\emph{Ситуацією рівноваги} для біматричної гри називається така пара $(x,y)$ мішаних стратегій Першого і Другого гравця відповідно, яка задовольняє такі умови:
\begin{equation} \sum_{j=1}^n a_{ij} y_j \leq H_1, i=\overline{1,m} \label{eq:bimatrbalance1}\end{equation}
\begin{equation} \sum_{i=1}^m b_{ij} x_i \leq H_2, j=\overline{1,n} \label{eq:bimatrbalance2}\end{equation}

Для відшукання ситуації рівноваги, потрібно роз’язати нерівності (\ref{eq:bimatrbalance1}-\ref{eq:bimatrbalance2}), за умов:
\[ \sum_{i=1}^m x_i = 1, x_i \geq 0, i = \overline{1,m}, \]
\[ \sum_{j=1}^n y_j = 1, y_j \geq 0, j = \overline{1,n}. \]

\clearpage

\section{Розв'язування біматричних ігор.}

Розглянемо випадок коли Перший і Другий гравець мають по дві стратегії. Тоді:\\
$A =$
\begin{tabular}{|c|c|}
\hline
$a_{1 1}$&$a_{1 2}$\\
\hline
$a_{2 1}$&$a_{2 2}$\\
\hline
\end{tabular},
$B =$
\begin{tabular}{|c|c|}
\hline
$b_{1 1}$&$b_{1 2}$\\
\hline
$b_{2 1}$&$b_{2 2}$\\
\hline
\end{tabular}

Мішані стратегії: Першого - $(x,1-x)$, Другого - $(y,1-y)$.

Визначимо (\ref{eq:bimatrbalance1}) і (\ref{eq:bimatrbalance2}):\\
\[\begin{array}{c}
H_1 = a_{11}xy + a_{12}x(1-y) + a_{21}(1-x)y + a_{22}(1-x)(1-y) =\\
= (a_{11}-a_{12}-a_{21}+a_{22})xy + (a_{12}-a_{22})x + (a_{21}-a_{22})y + a_{22}
\end{array}\]
\[H_2 = (b_{11}-b_{12}-b_{21}+b_{22})xy + (b_{12}-b_{22})x + (b_{21}-b_{22})y + b_{22} \]

Тоді із (\ref{eq:bimatrbalance1}) отримуємо:\\
$ i=1: a_{11}y+a_{12}(1-y) \leq (a_{11}-a_{12}-a_{21}+a_{22})xy + (a_{12}-a_{22})x + (a_{21}-a_{22})y + a_{22} $\\
$(a_{11}-a_{12}-a_{21}+a_{22})(1-x)y - (a_{22}-a_{12})(1-x) \leq 0$\\
Позначимо:\\
$a_1 = a_{11}-a_{12}-a_{21}+a_{22}$\\
$a_2 = a_{22}-a_{12}$\\
$a_1(1-x)y - a_2(1-x) \leq 0$\\
Аналогічно при $i=2$ отримаємо: $a_1xy - a_2x) \geq 0$.

Таким чином для відшукання ситуації рівноваги потрібно розв’язати:
\begin{equation} a_1(1-x)y - a_2(1-x) \leq 0 \label{eq:bimatrbalancesolving1} \end{equation}
\begin{equation} a_1xy - a_2x) \geq 0 \label{eq:bimatrbalancesolving2} \end{equation}
з умовами: $x,y \in [0,1]$.

Для цього розглянемо випадки:
\begin{slim_enumerate}
  \item $x=0$: (\ref{eq:bimatrbalancesolving2}) виконується $\forall y$, а з (\ref{eq:bimatrbalancesolving1}) $\Rightarrow a_1 y - a_2 \leq 0$
  \item $x=1$: (\ref{eq:bimatrbalancesolving1}) виконується $\forall y$, а з (\ref{eq:bimatrbalancesolving2}) $\Rightarrow a_1 y - a_2 \geq 0$
  \item $x \in (0,1)$: Поділивши (\ref{eq:bimatrbalancesolving1}) на $(1-x)>0$ отримаємо $a_1 y - a_2 \leq 0$, а поділивши (\ref{eq:bimatrbalancesolving2}) на на $x>0$ - $a_1 y - a_2 \geq 0$.

Звідси, $a_1 y - a_2 = 0$
\end{slim_enumerate}

Таким чином, множина $М$ сприятливих розв’язків для Першого складається із ситуацій вигляду:
\begin{slim_itemize}
  \item $a_1=a_2=0: x \in [0,1], y \in [0,1]$
  \item $a_1=0$,
  \begin{slim_enumerate}
    \item $a_2>0: x=0, y \in [0,1]$
    \item $a_2<0: x=1, y \in [0,1]$
  \end{slim_enumerate}
    \item $a_1>0:$
    \begin{slim_itemize}
      \item $x=0, y \leq \alpha$
      \item $x \in (0,1), y=\alpha$
      \item $x=1, y \geq \alpha$
    \end{slim_itemize}
    \item $a_1<0:$
    \begin{slim_itemize}
      \item $x=0, y \geq \alpha$
      \item $x \in (0,1), y=\alpha$
      \item $x=1, y \leq \alpha$
    \end{slim_itemize}
\end{slim_itemize}
де $\displaystyle \alpha = \frac{a_2}{a_1}$.

Аналогічно отримуємо множину $N$ сприятливих розв’язків для Другого гравця.

Розвязком гри є перетин $M \cap N$ тобто ті значення $x,y$ які є спільними для двох множин.

\end{document}